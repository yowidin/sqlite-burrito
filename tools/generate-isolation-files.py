import argparse
import re
import os
import errno

from io import StringIO


def write_if_changed(text, file_path):
    existing_text = ''
    if os.path.exists(file_path) and os.path.isfile(file_path):
        # file exists, trying to read
        with open(file_path, 'r') as f:
            existing_text = f.read()

    if existing_text != text:
        # file is changed, trying to write
        with open(file_path, 'w') as f:
            f.write(text)


def safe_mk_dirs(path):
    try:
        os.makedirs(path)
    except OSError as error:
        if error.errno == errno.EEXIST:
            pass
        else:
            raise


def parse_args():
    parser = argparse.ArgumentParser(description="""SQLite3 isolation files generator.
This script generates a separate header and source files to hide the SQLite3 defines from the 
global namespace.""")

    # Input
    input_options = parser.add_argument_group('Input')
    input_options.add_argument('-i', '--include-file', required=True,
                               help='Path to the SQLite3 include file')

    # Output
    out_parser = parser.add_argument_group('Output')
    out_parser.add_argument('--output-include-file', required=True,
                            help='Output path for the include file')
    out_parser.add_argument('--output-src-file', required=True,
                            help='Output path for the source file')

    return parser.parse_args()


def write_isolation_header(args, expressions):
    f = StringIO()

    print('// !!! THIS FILE IS AUTOMATICALLY GENERATED, YOUR CHANGES WILL BE LOST !!! //', file=f)
    print('// NOTE: See generate-isolation-files.py for details                       //', file=f)
    print('#ifndef SQLITE_BURRITO_ISOLATION_SQLITE3_H_', file=f)
    print('#define SQLITE_BURRITO_ISOLATION_SQLITE3_H_', file=f)
    print('', file=f)

    print('#include <sqlite-burrito/export.h>', file=f)
    print('', file=f)

    print('// In this header we try to isolate the library user from the SQLite3 symbols', file=f)
    print('// almost like some sort of... module... ðŸ¤”?', file=f)
    print('', file=f)

    print('namespace sqlite_burrito {', file=f)
    print('', file=f)

    print('SQLITE_BURRITO_EXPORT struct isolation {', file=f)
    for expression in expressions:
        print(expression, file=f)
    print('};\n', file=f)

    print('} // namespace sqlite_burrito', file=f)
    print('', file=f)

    print('#endif // SQLITE_BURRITO_ISOLATION_SQLITE3_H_', file=f)

    safe_mk_dirs(os.path.dirname(args.output_include_file))
    write_if_changed(f.getvalue(), args.output_include_file)


def write_isolation_source(args, strings, ints):
    f = StringIO()

    print('// !!! THIS FILE IS AUTOMATICALLY GENERATED, YOUR CHANGES WILL BE LOST !!! //', file=f)
    print('// NOTE: See generate-isolation-files.py for details                       //', file=f)
    print('', file=f)

    print('#include <sqlite-burrito/isolation/sqlite3.h>', file=f)
    print('', file=f)

    print('using namespace sqlite_burrito;', file=f)
    print('', file=f)

    for key in strings:
        print('const char * const isolation::%s = "%s";' % (key, strings[key]), file=f)
    print('', file=f)

    for key in ints:
        print('int isolation::%s = %s;' % (key, ints[key]), file=f)

    safe_mk_dirs(os.path.dirname(args.output_src_file))
    write_if_changed(f.getvalue(), args.output_src_file)


def main():
    args = parse_args()

    with open(args.include_file, 'r') as f:
        lines = f.readlines()

    expressions = []

    string_defines = {}
    int_defines = {}

    i = 0
    while i < len(lines):
        line = lines[i]

        def handle_char_def():
            m = re.match(r'^#define\s+(SQLITE_.+?)\s+\"(.+)\"', line)
            if m:
                expressions.append('   static const char * const %s;' % m.group(1))
                string_defines[m.group(1)] = m.group(2)
                return True

            return False

        def handle_int_def():
            m = re.match(r'^#define\s+(SQLITE_.+?)\s+((0x)?\d+|\(.+\))', line)
            if m:
                name = m.group(1)

                if name in ['SQLITE_STATIC', 'SQLITE_TRANSIENT']:
                    # Skip some esoteric defines
                    return False

                expressions.append('   static int %s;' % name)
                int_defines[m.group(1)] = m.group(2)
                return True

            return False

        i += 1

        if handle_char_def() or handle_int_def():
            continue

    write_isolation_header(args=args, expressions=expressions)
    write_isolation_source(args=args, ints=int_defines, strings=string_defines)


if __name__ == '__main__':
    main()
